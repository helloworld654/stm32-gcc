ARM GAS  /tmp/ccwKCxOP.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 6
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"stm32f10x_pwr.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.PWR_DeInit,"ax",%progbits
  16              		.align	1
  17              		.global	PWR_DeInit
  18              		.arch armv7-m
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu softvfp
  24              	PWR_DeInit:
  25              	.LFB63:
  26              		.file 1 "Drivers/Src/stm32f10x_pwr.c"
   1:Drivers/Src/stm32f10x_pwr.c **** /**
   2:Drivers/Src/stm32f10x_pwr.c ****   ******************************************************************************
   3:Drivers/Src/stm32f10x_pwr.c ****   * @file    stm32f10x_pwr.c
   4:Drivers/Src/stm32f10x_pwr.c ****   * @author  MCD Application Team
   5:Drivers/Src/stm32f10x_pwr.c ****   * @version V3.5.0
   6:Drivers/Src/stm32f10x_pwr.c ****   * @date    11-March-2011
   7:Drivers/Src/stm32f10x_pwr.c ****   * @brief   This file provides all the PWR firmware functions.
   8:Drivers/Src/stm32f10x_pwr.c ****   ******************************************************************************
   9:Drivers/Src/stm32f10x_pwr.c ****   * @attention
  10:Drivers/Src/stm32f10x_pwr.c ****   *
  11:Drivers/Src/stm32f10x_pwr.c ****   * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
  12:Drivers/Src/stm32f10x_pwr.c ****   * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
  13:Drivers/Src/stm32f10x_pwr.c ****   * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
  14:Drivers/Src/stm32f10x_pwr.c ****   * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
  15:Drivers/Src/stm32f10x_pwr.c ****   * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
  16:Drivers/Src/stm32f10x_pwr.c ****   * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
  17:Drivers/Src/stm32f10x_pwr.c ****   *
  18:Drivers/Src/stm32f10x_pwr.c ****   * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
  19:Drivers/Src/stm32f10x_pwr.c ****   ******************************************************************************
  20:Drivers/Src/stm32f10x_pwr.c ****   */
  21:Drivers/Src/stm32f10x_pwr.c **** 
  22:Drivers/Src/stm32f10x_pwr.c **** /* Includes ------------------------------------------------------------------*/
  23:Drivers/Src/stm32f10x_pwr.c **** #include "stm32f10x_pwr.h"
  24:Drivers/Src/stm32f10x_pwr.c **** #include "stm32f10x_rcc.h"
  25:Drivers/Src/stm32f10x_pwr.c **** 
  26:Drivers/Src/stm32f10x_pwr.c **** /** @addtogroup STM32F10x_StdPeriph_Driver
  27:Drivers/Src/stm32f10x_pwr.c ****   * @{
  28:Drivers/Src/stm32f10x_pwr.c ****   */
  29:Drivers/Src/stm32f10x_pwr.c **** 
  30:Drivers/Src/stm32f10x_pwr.c **** /** @defgroup PWR 
  31:Drivers/Src/stm32f10x_pwr.c ****   * @brief PWR driver modules
  32:Drivers/Src/stm32f10x_pwr.c ****   * @{
ARM GAS  /tmp/ccwKCxOP.s 			page 2


  33:Drivers/Src/stm32f10x_pwr.c ****   */ 
  34:Drivers/Src/stm32f10x_pwr.c **** 
  35:Drivers/Src/stm32f10x_pwr.c **** /** @defgroup PWR_Private_TypesDefinitions
  36:Drivers/Src/stm32f10x_pwr.c ****   * @{
  37:Drivers/Src/stm32f10x_pwr.c ****   */
  38:Drivers/Src/stm32f10x_pwr.c **** 
  39:Drivers/Src/stm32f10x_pwr.c **** /**
  40:Drivers/Src/stm32f10x_pwr.c ****   * @}
  41:Drivers/Src/stm32f10x_pwr.c ****   */
  42:Drivers/Src/stm32f10x_pwr.c **** 
  43:Drivers/Src/stm32f10x_pwr.c **** /** @defgroup PWR_Private_Defines
  44:Drivers/Src/stm32f10x_pwr.c ****   * @{
  45:Drivers/Src/stm32f10x_pwr.c ****   */
  46:Drivers/Src/stm32f10x_pwr.c **** 
  47:Drivers/Src/stm32f10x_pwr.c **** /* --------- PWR registers bit address in the alias region ---------- */
  48:Drivers/Src/stm32f10x_pwr.c **** #define PWR_OFFSET               (PWR_BASE - PERIPH_BASE)
  49:Drivers/Src/stm32f10x_pwr.c **** 
  50:Drivers/Src/stm32f10x_pwr.c **** /* --- CR Register ---*/
  51:Drivers/Src/stm32f10x_pwr.c **** 
  52:Drivers/Src/stm32f10x_pwr.c **** /* Alias word address of DBP bit */
  53:Drivers/Src/stm32f10x_pwr.c **** #define CR_OFFSET                (PWR_OFFSET + 0x00)
  54:Drivers/Src/stm32f10x_pwr.c **** #define DBP_BitNumber            0x08
  55:Drivers/Src/stm32f10x_pwr.c **** #define CR_DBP_BB                (PERIPH_BB_BASE + (CR_OFFSET * 32) + (DBP_BitNumber * 4))
  56:Drivers/Src/stm32f10x_pwr.c **** 
  57:Drivers/Src/stm32f10x_pwr.c **** /* Alias word address of PVDE bit */
  58:Drivers/Src/stm32f10x_pwr.c **** #define PVDE_BitNumber           0x04
  59:Drivers/Src/stm32f10x_pwr.c **** #define CR_PVDE_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PVDE_BitNumber * 4))
  60:Drivers/Src/stm32f10x_pwr.c **** 
  61:Drivers/Src/stm32f10x_pwr.c **** /* --- CSR Register ---*/
  62:Drivers/Src/stm32f10x_pwr.c **** 
  63:Drivers/Src/stm32f10x_pwr.c **** /* Alias word address of EWUP bit */
  64:Drivers/Src/stm32f10x_pwr.c **** #define CSR_OFFSET               (PWR_OFFSET + 0x04)
  65:Drivers/Src/stm32f10x_pwr.c **** #define EWUP_BitNumber           0x08
  66:Drivers/Src/stm32f10x_pwr.c **** #define CSR_EWUP_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (EWUP_BitNumber * 4))
  67:Drivers/Src/stm32f10x_pwr.c **** 
  68:Drivers/Src/stm32f10x_pwr.c **** /* ------------------ PWR registers bit mask ------------------------ */
  69:Drivers/Src/stm32f10x_pwr.c **** 
  70:Drivers/Src/stm32f10x_pwr.c **** /* CR register bit mask */
  71:Drivers/Src/stm32f10x_pwr.c **** #define CR_DS_MASK               ((uint32_t)0xFFFFFFFC)
  72:Drivers/Src/stm32f10x_pwr.c **** #define CR_PLS_MASK              ((uint32_t)0xFFFFFF1F)
  73:Drivers/Src/stm32f10x_pwr.c **** 
  74:Drivers/Src/stm32f10x_pwr.c **** 
  75:Drivers/Src/stm32f10x_pwr.c **** /**
  76:Drivers/Src/stm32f10x_pwr.c ****   * @}
  77:Drivers/Src/stm32f10x_pwr.c ****   */
  78:Drivers/Src/stm32f10x_pwr.c **** 
  79:Drivers/Src/stm32f10x_pwr.c **** /** @defgroup PWR_Private_Macros
  80:Drivers/Src/stm32f10x_pwr.c ****   * @{
  81:Drivers/Src/stm32f10x_pwr.c ****   */
  82:Drivers/Src/stm32f10x_pwr.c **** 
  83:Drivers/Src/stm32f10x_pwr.c **** /**
  84:Drivers/Src/stm32f10x_pwr.c ****   * @}
  85:Drivers/Src/stm32f10x_pwr.c ****   */
  86:Drivers/Src/stm32f10x_pwr.c **** 
  87:Drivers/Src/stm32f10x_pwr.c **** /** @defgroup PWR_Private_Variables
  88:Drivers/Src/stm32f10x_pwr.c ****   * @{
  89:Drivers/Src/stm32f10x_pwr.c ****   */
ARM GAS  /tmp/ccwKCxOP.s 			page 3


  90:Drivers/Src/stm32f10x_pwr.c **** 
  91:Drivers/Src/stm32f10x_pwr.c **** /**
  92:Drivers/Src/stm32f10x_pwr.c ****   * @}
  93:Drivers/Src/stm32f10x_pwr.c ****   */
  94:Drivers/Src/stm32f10x_pwr.c **** 
  95:Drivers/Src/stm32f10x_pwr.c **** /** @defgroup PWR_Private_FunctionPrototypes
  96:Drivers/Src/stm32f10x_pwr.c ****   * @{
  97:Drivers/Src/stm32f10x_pwr.c ****   */
  98:Drivers/Src/stm32f10x_pwr.c **** 
  99:Drivers/Src/stm32f10x_pwr.c **** /**
 100:Drivers/Src/stm32f10x_pwr.c ****   * @}
 101:Drivers/Src/stm32f10x_pwr.c ****   */
 102:Drivers/Src/stm32f10x_pwr.c **** 
 103:Drivers/Src/stm32f10x_pwr.c **** /** @defgroup PWR_Private_Functions
 104:Drivers/Src/stm32f10x_pwr.c ****   * @{
 105:Drivers/Src/stm32f10x_pwr.c ****   */
 106:Drivers/Src/stm32f10x_pwr.c **** 
 107:Drivers/Src/stm32f10x_pwr.c **** /**
 108:Drivers/Src/stm32f10x_pwr.c ****   * @brief  Deinitializes the PWR peripheral registers to their default reset values.
 109:Drivers/Src/stm32f10x_pwr.c ****   * @param  None
 110:Drivers/Src/stm32f10x_pwr.c ****   * @retval None
 111:Drivers/Src/stm32f10x_pwr.c ****   */
 112:Drivers/Src/stm32f10x_pwr.c **** void PWR_DeInit(void)
 113:Drivers/Src/stm32f10x_pwr.c **** {
  27              		.loc 1 113 1
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 1, uses_anonymous_args = 0
  31 0000 80B5     		push	{r7, lr}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 8
  34              		.cfi_offset 7, -8
  35              		.cfi_offset 14, -4
  36 0002 00AF     		add	r7, sp, #0
  37              	.LCFI1:
  38              		.cfi_def_cfa_register 7
 114:Drivers/Src/stm32f10x_pwr.c ****   RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
  39              		.loc 1 114 3
  40 0004 0121     		movs	r1, #1
  41 0006 4FF08050 		mov	r0, #268435456
  42 000a FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 115:Drivers/Src/stm32f10x_pwr.c ****   RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
  43              		.loc 1 115 3
  44 000e 0021     		movs	r1, #0
  45 0010 4FF08050 		mov	r0, #268435456
  46 0014 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 116:Drivers/Src/stm32f10x_pwr.c **** }
  47              		.loc 1 116 1
  48 0018 00BF     		nop
  49 001a 80BD     		pop	{r7, pc}
  50              		.cfi_endproc
  51              	.LFE63:
  53              		.section	.text.PWR_BackupAccessCmd,"ax",%progbits
  54              		.align	1
  55              		.global	PWR_BackupAccessCmd
  56              		.syntax unified
  57              		.thumb
ARM GAS  /tmp/ccwKCxOP.s 			page 4


  58              		.thumb_func
  59              		.fpu softvfp
  61              	PWR_BackupAccessCmd:
  62              	.LFB64:
 117:Drivers/Src/stm32f10x_pwr.c **** 
 118:Drivers/Src/stm32f10x_pwr.c **** /**
 119:Drivers/Src/stm32f10x_pwr.c ****   * @brief  Enables or disables access to the RTC and backup registers.
 120:Drivers/Src/stm32f10x_pwr.c ****   * @param  NewState: new state of the access to the RTC and backup registers.
 121:Drivers/Src/stm32f10x_pwr.c ****   *   This parameter can be: ENABLE or DISABLE.
 122:Drivers/Src/stm32f10x_pwr.c ****   * @retval None
 123:Drivers/Src/stm32f10x_pwr.c ****   */
 124:Drivers/Src/stm32f10x_pwr.c **** void PWR_BackupAccessCmd(FunctionalState NewState)
 125:Drivers/Src/stm32f10x_pwr.c **** {
  63              		.loc 1 125 1
  64              		.cfi_startproc
  65              		@ args = 0, pretend = 0, frame = 8
  66              		@ frame_needed = 1, uses_anonymous_args = 0
  67              		@ link register save eliminated.
  68 0000 80B4     		push	{r7}
  69              	.LCFI2:
  70              		.cfi_def_cfa_offset 4
  71              		.cfi_offset 7, -4
  72 0002 83B0     		sub	sp, sp, #12
  73              	.LCFI3:
  74              		.cfi_def_cfa_offset 16
  75 0004 00AF     		add	r7, sp, #0
  76              	.LCFI4:
  77              		.cfi_def_cfa_register 7
  78 0006 0346     		mov	r3, r0
  79 0008 FB71     		strb	r3, [r7, #7]
 126:Drivers/Src/stm32f10x_pwr.c ****   /* Check the parameters */
 127:Drivers/Src/stm32f10x_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 128:Drivers/Src/stm32f10x_pwr.c ****   *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
  80              		.loc 1 128 3
  81 000a 044A     		ldr	r2, .L3
  82              		.loc 1 128 34
  83 000c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
  84              		.loc 1 128 32
  85 000e 1360     		str	r3, [r2]
 129:Drivers/Src/stm32f10x_pwr.c **** }
  86              		.loc 1 129 1
  87 0010 00BF     		nop
  88 0012 0C37     		adds	r7, r7, #12
  89              	.LCFI5:
  90              		.cfi_def_cfa_offset 4
  91 0014 BD46     		mov	sp, r7
  92              	.LCFI6:
  93              		.cfi_def_cfa_register 13
  94              		@ sp needed
  95 0016 80BC     		pop	{r7}
  96              	.LCFI7:
  97              		.cfi_restore 7
  98              		.cfi_def_cfa_offset 0
  99 0018 7047     		bx	lr
 100              	.L4:
 101 001a 00BF     		.align	2
 102              	.L3:
ARM GAS  /tmp/ccwKCxOP.s 			page 5


 103 001c 20000E42 		.word	1108213792
 104              		.cfi_endproc
 105              	.LFE64:
 107              		.section	.text.PWR_PVDCmd,"ax",%progbits
 108              		.align	1
 109              		.global	PWR_PVDCmd
 110              		.syntax unified
 111              		.thumb
 112              		.thumb_func
 113              		.fpu softvfp
 115              	PWR_PVDCmd:
 116              	.LFB65:
 130:Drivers/Src/stm32f10x_pwr.c **** 
 131:Drivers/Src/stm32f10x_pwr.c **** /**
 132:Drivers/Src/stm32f10x_pwr.c ****   * @brief  Enables or disables the Power Voltage Detector(PVD).
 133:Drivers/Src/stm32f10x_pwr.c ****   * @param  NewState: new state of the PVD.
 134:Drivers/Src/stm32f10x_pwr.c ****   *   This parameter can be: ENABLE or DISABLE.
 135:Drivers/Src/stm32f10x_pwr.c ****   * @retval None
 136:Drivers/Src/stm32f10x_pwr.c ****   */
 137:Drivers/Src/stm32f10x_pwr.c **** void PWR_PVDCmd(FunctionalState NewState)
 138:Drivers/Src/stm32f10x_pwr.c **** {
 117              		.loc 1 138 1
 118              		.cfi_startproc
 119              		@ args = 0, pretend = 0, frame = 8
 120              		@ frame_needed = 1, uses_anonymous_args = 0
 121              		@ link register save eliminated.
 122 0000 80B4     		push	{r7}
 123              	.LCFI8:
 124              		.cfi_def_cfa_offset 4
 125              		.cfi_offset 7, -4
 126 0002 83B0     		sub	sp, sp, #12
 127              	.LCFI9:
 128              		.cfi_def_cfa_offset 16
 129 0004 00AF     		add	r7, sp, #0
 130              	.LCFI10:
 131              		.cfi_def_cfa_register 7
 132 0006 0346     		mov	r3, r0
 133 0008 FB71     		strb	r3, [r7, #7]
 139:Drivers/Src/stm32f10x_pwr.c ****   /* Check the parameters */
 140:Drivers/Src/stm32f10x_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 141:Drivers/Src/stm32f10x_pwr.c ****   *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)NewState;
 134              		.loc 1 141 3
 135 000a 044A     		ldr	r2, .L6
 136              		.loc 1 141 35
 137 000c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 138              		.loc 1 141 33
 139 000e 1360     		str	r3, [r2]
 142:Drivers/Src/stm32f10x_pwr.c **** }
 140              		.loc 1 142 1
 141 0010 00BF     		nop
 142 0012 0C37     		adds	r7, r7, #12
 143              	.LCFI11:
 144              		.cfi_def_cfa_offset 4
 145 0014 BD46     		mov	sp, r7
 146              	.LCFI12:
 147              		.cfi_def_cfa_register 13
 148              		@ sp needed
ARM GAS  /tmp/ccwKCxOP.s 			page 6


 149 0016 80BC     		pop	{r7}
 150              	.LCFI13:
 151              		.cfi_restore 7
 152              		.cfi_def_cfa_offset 0
 153 0018 7047     		bx	lr
 154              	.L7:
 155 001a 00BF     		.align	2
 156              	.L6:
 157 001c 10000E42 		.word	1108213776
 158              		.cfi_endproc
 159              	.LFE65:
 161              		.section	.text.PWR_PVDLevelConfig,"ax",%progbits
 162              		.align	1
 163              		.global	PWR_PVDLevelConfig
 164              		.syntax unified
 165              		.thumb
 166              		.thumb_func
 167              		.fpu softvfp
 169              	PWR_PVDLevelConfig:
 170              	.LFB66:
 143:Drivers/Src/stm32f10x_pwr.c **** 
 144:Drivers/Src/stm32f10x_pwr.c **** /**
 145:Drivers/Src/stm32f10x_pwr.c ****   * @brief  Configures the voltage threshold detected by the Power Voltage Detector(PVD).
 146:Drivers/Src/stm32f10x_pwr.c ****   * @param  PWR_PVDLevel: specifies the PVD detection level
 147:Drivers/Src/stm32f10x_pwr.c ****   *   This parameter can be one of the following values:
 148:Drivers/Src/stm32f10x_pwr.c ****   *     @arg PWR_PVDLevel_2V2: PVD detection level set to 2.2V
 149:Drivers/Src/stm32f10x_pwr.c ****   *     @arg PWR_PVDLevel_2V3: PVD detection level set to 2.3V
 150:Drivers/Src/stm32f10x_pwr.c ****   *     @arg PWR_PVDLevel_2V4: PVD detection level set to 2.4V
 151:Drivers/Src/stm32f10x_pwr.c ****   *     @arg PWR_PVDLevel_2V5: PVD detection level set to 2.5V
 152:Drivers/Src/stm32f10x_pwr.c ****   *     @arg PWR_PVDLevel_2V6: PVD detection level set to 2.6V
 153:Drivers/Src/stm32f10x_pwr.c ****   *     @arg PWR_PVDLevel_2V7: PVD detection level set to 2.7V
 154:Drivers/Src/stm32f10x_pwr.c ****   *     @arg PWR_PVDLevel_2V8: PVD detection level set to 2.8V
 155:Drivers/Src/stm32f10x_pwr.c ****   *     @arg PWR_PVDLevel_2V9: PVD detection level set to 2.9V
 156:Drivers/Src/stm32f10x_pwr.c ****   * @retval None
 157:Drivers/Src/stm32f10x_pwr.c ****   */
 158:Drivers/Src/stm32f10x_pwr.c **** void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel)
 159:Drivers/Src/stm32f10x_pwr.c **** {
 171              		.loc 1 159 1
 172              		.cfi_startproc
 173              		@ args = 0, pretend = 0, frame = 16
 174              		@ frame_needed = 1, uses_anonymous_args = 0
 175              		@ link register save eliminated.
 176 0000 80B4     		push	{r7}
 177              	.LCFI14:
 178              		.cfi_def_cfa_offset 4
 179              		.cfi_offset 7, -4
 180 0002 85B0     		sub	sp, sp, #20
 181              	.LCFI15:
 182              		.cfi_def_cfa_offset 24
 183 0004 00AF     		add	r7, sp, #0
 184              	.LCFI16:
 185              		.cfi_def_cfa_register 7
 186 0006 7860     		str	r0, [r7, #4]
 160:Drivers/Src/stm32f10x_pwr.c ****   uint32_t tmpreg = 0;
 187              		.loc 1 160 12
 188 0008 0023     		movs	r3, #0
 189 000a FB60     		str	r3, [r7, #12]
ARM GAS  /tmp/ccwKCxOP.s 			page 7


 161:Drivers/Src/stm32f10x_pwr.c ****   /* Check the parameters */
 162:Drivers/Src/stm32f10x_pwr.c ****   assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
 163:Drivers/Src/stm32f10x_pwr.c ****   tmpreg = PWR->CR;
 190              		.loc 1 163 15
 191 000c 094B     		ldr	r3, .L9
 192              		.loc 1 163 10
 193 000e 1B68     		ldr	r3, [r3]
 194 0010 FB60     		str	r3, [r7, #12]
 164:Drivers/Src/stm32f10x_pwr.c ****   /* Clear PLS[7:5] bits */
 165:Drivers/Src/stm32f10x_pwr.c ****   tmpreg &= CR_PLS_MASK;
 195              		.loc 1 165 10
 196 0012 FB68     		ldr	r3, [r7, #12]
 197 0014 23F0E003 		bic	r3, r3, #224
 198 0018 FB60     		str	r3, [r7, #12]
 166:Drivers/Src/stm32f10x_pwr.c ****   /* Set PLS[7:5] bits according to PWR_PVDLevel value */
 167:Drivers/Src/stm32f10x_pwr.c ****   tmpreg |= PWR_PVDLevel;
 199              		.loc 1 167 10
 200 001a FA68     		ldr	r2, [r7, #12]
 201 001c 7B68     		ldr	r3, [r7, #4]
 202 001e 1343     		orrs	r3, r3, r2
 203 0020 FB60     		str	r3, [r7, #12]
 168:Drivers/Src/stm32f10x_pwr.c ****   /* Store the new value */
 169:Drivers/Src/stm32f10x_pwr.c ****   PWR->CR = tmpreg;
 204              		.loc 1 169 6
 205 0022 044A     		ldr	r2, .L9
 206              		.loc 1 169 11
 207 0024 FB68     		ldr	r3, [r7, #12]
 208 0026 1360     		str	r3, [r2]
 170:Drivers/Src/stm32f10x_pwr.c **** }
 209              		.loc 1 170 1
 210 0028 00BF     		nop
 211 002a 1437     		adds	r7, r7, #20
 212              	.LCFI17:
 213              		.cfi_def_cfa_offset 4
 214 002c BD46     		mov	sp, r7
 215              	.LCFI18:
 216              		.cfi_def_cfa_register 13
 217              		@ sp needed
 218 002e 80BC     		pop	{r7}
 219              	.LCFI19:
 220              		.cfi_restore 7
 221              		.cfi_def_cfa_offset 0
 222 0030 7047     		bx	lr
 223              	.L10:
 224 0032 00BF     		.align	2
 225              	.L9:
 226 0034 00700040 		.word	1073770496
 227              		.cfi_endproc
 228              	.LFE66:
 230              		.section	.text.PWR_WakeUpPinCmd,"ax",%progbits
 231              		.align	1
 232              		.global	PWR_WakeUpPinCmd
 233              		.syntax unified
 234              		.thumb
 235              		.thumb_func
 236              		.fpu softvfp
 238              	PWR_WakeUpPinCmd:
ARM GAS  /tmp/ccwKCxOP.s 			page 8


 239              	.LFB67:
 171:Drivers/Src/stm32f10x_pwr.c **** 
 172:Drivers/Src/stm32f10x_pwr.c **** /**
 173:Drivers/Src/stm32f10x_pwr.c ****   * @brief  Enables or disables the WakeUp Pin functionality.
 174:Drivers/Src/stm32f10x_pwr.c ****   * @param  NewState: new state of the WakeUp Pin functionality.
 175:Drivers/Src/stm32f10x_pwr.c ****   *   This parameter can be: ENABLE or DISABLE.
 176:Drivers/Src/stm32f10x_pwr.c ****   * @retval None
 177:Drivers/Src/stm32f10x_pwr.c ****   */
 178:Drivers/Src/stm32f10x_pwr.c **** void PWR_WakeUpPinCmd(FunctionalState NewState)
 179:Drivers/Src/stm32f10x_pwr.c **** {
 240              		.loc 1 179 1
 241              		.cfi_startproc
 242              		@ args = 0, pretend = 0, frame = 8
 243              		@ frame_needed = 1, uses_anonymous_args = 0
 244              		@ link register save eliminated.
 245 0000 80B4     		push	{r7}
 246              	.LCFI20:
 247              		.cfi_def_cfa_offset 4
 248              		.cfi_offset 7, -4
 249 0002 83B0     		sub	sp, sp, #12
 250              	.LCFI21:
 251              		.cfi_def_cfa_offset 16
 252 0004 00AF     		add	r7, sp, #0
 253              	.LCFI22:
 254              		.cfi_def_cfa_register 7
 255 0006 0346     		mov	r3, r0
 256 0008 FB71     		strb	r3, [r7, #7]
 180:Drivers/Src/stm32f10x_pwr.c ****   /* Check the parameters */
 181:Drivers/Src/stm32f10x_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 182:Drivers/Src/stm32f10x_pwr.c ****   *(__IO uint32_t *) CSR_EWUP_BB = (uint32_t)NewState;
 257              		.loc 1 182 3
 258 000a 044A     		ldr	r2, .L12
 259              		.loc 1 182 36
 260 000c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 261              		.loc 1 182 34
 262 000e 1360     		str	r3, [r2]
 183:Drivers/Src/stm32f10x_pwr.c **** }
 263              		.loc 1 183 1
 264 0010 00BF     		nop
 265 0012 0C37     		adds	r7, r7, #12
 266              	.LCFI23:
 267              		.cfi_def_cfa_offset 4
 268 0014 BD46     		mov	sp, r7
 269              	.LCFI24:
 270              		.cfi_def_cfa_register 13
 271              		@ sp needed
 272 0016 80BC     		pop	{r7}
 273              	.LCFI25:
 274              		.cfi_restore 7
 275              		.cfi_def_cfa_offset 0
 276 0018 7047     		bx	lr
 277              	.L13:
 278 001a 00BF     		.align	2
 279              	.L12:
 280 001c A0000E42 		.word	1108213920
 281              		.cfi_endproc
 282              	.LFE67:
ARM GAS  /tmp/ccwKCxOP.s 			page 9


 284              		.section	.text.PWR_EnterSTOPMode,"ax",%progbits
 285              		.align	1
 286              		.global	PWR_EnterSTOPMode
 287              		.syntax unified
 288              		.thumb
 289              		.thumb_func
 290              		.fpu softvfp
 292              	PWR_EnterSTOPMode:
 293              	.LFB68:
 184:Drivers/Src/stm32f10x_pwr.c **** 
 185:Drivers/Src/stm32f10x_pwr.c **** /**
 186:Drivers/Src/stm32f10x_pwr.c ****   * @brief  Enters STOP mode.
 187:Drivers/Src/stm32f10x_pwr.c ****   * @param  PWR_Regulator: specifies the regulator state in STOP mode.
 188:Drivers/Src/stm32f10x_pwr.c ****   *   This parameter can be one of the following values:
 189:Drivers/Src/stm32f10x_pwr.c ****   *     @arg PWR_Regulator_ON: STOP mode with regulator ON
 190:Drivers/Src/stm32f10x_pwr.c ****   *     @arg PWR_Regulator_LowPower: STOP mode with regulator in low power mode
 191:Drivers/Src/stm32f10x_pwr.c ****   * @param  PWR_STOPEntry: specifies if STOP mode in entered with WFI or WFE instruction.
 192:Drivers/Src/stm32f10x_pwr.c ****   *   This parameter can be one of the following values:
 193:Drivers/Src/stm32f10x_pwr.c ****   *     @arg PWR_STOPEntry_WFI: enter STOP mode with WFI instruction
 194:Drivers/Src/stm32f10x_pwr.c ****   *     @arg PWR_STOPEntry_WFE: enter STOP mode with WFE instruction
 195:Drivers/Src/stm32f10x_pwr.c ****   * @retval None
 196:Drivers/Src/stm32f10x_pwr.c ****   */
 197:Drivers/Src/stm32f10x_pwr.c **** void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)
 198:Drivers/Src/stm32f10x_pwr.c **** {
 294              		.loc 1 198 1
 295              		.cfi_startproc
 296              		@ args = 0, pretend = 0, frame = 16
 297              		@ frame_needed = 1, uses_anonymous_args = 0
 298              		@ link register save eliminated.
 299 0000 80B4     		push	{r7}
 300              	.LCFI26:
 301              		.cfi_def_cfa_offset 4
 302              		.cfi_offset 7, -4
 303 0002 85B0     		sub	sp, sp, #20
 304              	.LCFI27:
 305              		.cfi_def_cfa_offset 24
 306 0004 00AF     		add	r7, sp, #0
 307              	.LCFI28:
 308              		.cfi_def_cfa_register 7
 309 0006 7860     		str	r0, [r7, #4]
 310 0008 0B46     		mov	r3, r1
 311 000a FB70     		strb	r3, [r7, #3]
 199:Drivers/Src/stm32f10x_pwr.c ****   uint32_t tmpreg = 0;
 312              		.loc 1 199 12
 313 000c 0023     		movs	r3, #0
 314 000e FB60     		str	r3, [r7, #12]
 200:Drivers/Src/stm32f10x_pwr.c ****   /* Check the parameters */
 201:Drivers/Src/stm32f10x_pwr.c ****   assert_param(IS_PWR_REGULATOR(PWR_Regulator));
 202:Drivers/Src/stm32f10x_pwr.c ****   assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
 203:Drivers/Src/stm32f10x_pwr.c ****   
 204:Drivers/Src/stm32f10x_pwr.c ****   /* Select the regulator state in STOP mode ---------------------------------*/
 205:Drivers/Src/stm32f10x_pwr.c ****   tmpreg = PWR->CR;
 315              		.loc 1 205 15
 316 0010 124B     		ldr	r3, .L17
 317              		.loc 1 205 10
 318 0012 1B68     		ldr	r3, [r3]
 319 0014 FB60     		str	r3, [r7, #12]
ARM GAS  /tmp/ccwKCxOP.s 			page 10


 206:Drivers/Src/stm32f10x_pwr.c ****   /* Clear PDDS and LPDS bits */
 207:Drivers/Src/stm32f10x_pwr.c ****   tmpreg &= CR_DS_MASK;
 320              		.loc 1 207 10
 321 0016 FB68     		ldr	r3, [r7, #12]
 322 0018 23F00303 		bic	r3, r3, #3
 323 001c FB60     		str	r3, [r7, #12]
 208:Drivers/Src/stm32f10x_pwr.c ****   /* Set LPDS bit according to PWR_Regulator value */
 209:Drivers/Src/stm32f10x_pwr.c ****   tmpreg |= PWR_Regulator;
 324              		.loc 1 209 10
 325 001e FA68     		ldr	r2, [r7, #12]
 326 0020 7B68     		ldr	r3, [r7, #4]
 327 0022 1343     		orrs	r3, r3, r2
 328 0024 FB60     		str	r3, [r7, #12]
 210:Drivers/Src/stm32f10x_pwr.c ****   /* Store the new value */
 211:Drivers/Src/stm32f10x_pwr.c ****   PWR->CR = tmpreg;
 329              		.loc 1 211 6
 330 0026 0D4A     		ldr	r2, .L17
 331              		.loc 1 211 11
 332 0028 FB68     		ldr	r3, [r7, #12]
 333 002a 1360     		str	r3, [r2]
 212:Drivers/Src/stm32f10x_pwr.c ****   /* Set SLEEPDEEP bit of Cortex System Control Register */
 213:Drivers/Src/stm32f10x_pwr.c ****   SCB->SCR |= SCB_SCR_SLEEPDEEP;
 334              		.loc 1 213 12
 335 002c 0C4B     		ldr	r3, .L17+4
 336 002e 1B69     		ldr	r3, [r3, #16]
 337 0030 0B4A     		ldr	r2, .L17+4
 338 0032 43F00403 		orr	r3, r3, #4
 339 0036 1361     		str	r3, [r2, #16]
 214:Drivers/Src/stm32f10x_pwr.c ****   
 215:Drivers/Src/stm32f10x_pwr.c ****   /* Select STOP mode entry --------------------------------------------------*/
 216:Drivers/Src/stm32f10x_pwr.c ****   if(PWR_STOPEntry == PWR_STOPEntry_WFI)
 340              		.loc 1 216 5
 341 0038 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 342 003a 012B     		cmp	r3, #1
 343 003c 01D1     		bne	.L15
 344              	.LBB8:
 345              	.LBB9:
 346              		.file 2 "Drivers/CMSIS/Include/cmsis_gcc.h"
   1:Drivers/CMSIS/Include/cmsis_gcc.h **** /**************************************************************************//**
   2:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @brief    CMSIS Cortex-M Core Function/Instruction Header File
   4:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @version  V4.30
   5:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @date     20. October 2015
   6:Drivers/CMSIS/Include/cmsis_gcc.h ****  ******************************************************************************/
   7:Drivers/CMSIS/Include/cmsis_gcc.h **** /* Copyright (c) 2009 - 2015 ARM LIMITED
   8:Drivers/CMSIS/Include/cmsis_gcc.h **** 
   9:Drivers/CMSIS/Include/cmsis_gcc.h ****    All rights reserved.
  10:Drivers/CMSIS/Include/cmsis_gcc.h ****    Redistribution and use in source and binary forms, with or without
  11:Drivers/CMSIS/Include/cmsis_gcc.h ****    modification, are permitted provided that the following conditions are met:
  12:Drivers/CMSIS/Include/cmsis_gcc.h ****    - Redistributions of source code must retain the above copyright
  13:Drivers/CMSIS/Include/cmsis_gcc.h ****      notice, this list of conditions and the following disclaimer.
  14:Drivers/CMSIS/Include/cmsis_gcc.h ****    - Redistributions in binary form must reproduce the above copyright
  15:Drivers/CMSIS/Include/cmsis_gcc.h ****      notice, this list of conditions and the following disclaimer in the
  16:Drivers/CMSIS/Include/cmsis_gcc.h ****      documentation and/or other materials provided with the distribution.
  17:Drivers/CMSIS/Include/cmsis_gcc.h ****    - Neither the name of ARM nor the names of its contributors may be used
  18:Drivers/CMSIS/Include/cmsis_gcc.h ****      to endorse or promote products derived from this software without
  19:Drivers/CMSIS/Include/cmsis_gcc.h ****      specific prior written permission.
ARM GAS  /tmp/ccwKCxOP.s 			page 11


  20:Drivers/CMSIS/Include/cmsis_gcc.h ****    *
  21:Drivers/CMSIS/Include/cmsis_gcc.h ****    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:Drivers/CMSIS/Include/cmsis_gcc.h ****    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:Drivers/CMSIS/Include/cmsis_gcc.h ****    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:Drivers/CMSIS/Include/cmsis_gcc.h ****    ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
  25:Drivers/CMSIS/Include/cmsis_gcc.h ****    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:Drivers/CMSIS/Include/cmsis_gcc.h ****    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:Drivers/CMSIS/Include/cmsis_gcc.h ****    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:Drivers/CMSIS/Include/cmsis_gcc.h ****    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:Drivers/CMSIS/Include/cmsis_gcc.h ****    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:Drivers/CMSIS/Include/cmsis_gcc.h ****    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:Drivers/CMSIS/Include/cmsis_gcc.h ****    POSSIBILITY OF SUCH DAMAGE.
  32:Drivers/CMSIS/Include/cmsis_gcc.h ****    ---------------------------------------------------------------------------*/
  33:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  34:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  35:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  36:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_H
  37:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  38:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ignore some GCC warnings */
  39:Drivers/CMSIS/Include/cmsis_gcc.h **** #if defined ( __GNUC__ )
  40:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic push
  41:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  42:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  43:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  44:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  45:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  46:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  47:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
  48:Drivers/CMSIS/Include/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
  49:Drivers/CMSIS/Include/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
  50:Drivers/CMSIS/Include/cmsis_gcc.h ****   @{
  51:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  52:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  53:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
  54:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
  55:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
  56:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
  57:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  58:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
  59:Drivers/CMSIS/Include/cmsis_gcc.h **** {
  60:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
  61:Drivers/CMSIS/Include/cmsis_gcc.h **** }
  62:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  63:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  64:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
  65:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
  66:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  67:Drivers/CMSIS/Include/cmsis_gcc.h ****   Can only be executed in Privileged modes.
  68:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  69:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
  70:Drivers/CMSIS/Include/cmsis_gcc.h **** {
  71:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
  72:Drivers/CMSIS/Include/cmsis_gcc.h **** }
  73:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  74:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  75:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
  76:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register
ARM GAS  /tmp/ccwKCxOP.s 			page 12


  77:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the Control Register.
  78:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Control Register value
  79:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  80:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
  81:Drivers/CMSIS/Include/cmsis_gcc.h **** {
  82:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
  83:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  84:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
  85:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
  86:Drivers/CMSIS/Include/cmsis_gcc.h **** }
  87:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  88:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  89:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
  90:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register
  91:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
  92:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
  93:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  94:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
  95:Drivers/CMSIS/Include/cmsis_gcc.h **** {
  96:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
  97:Drivers/CMSIS/Include/cmsis_gcc.h **** }
  98:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  99:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 100:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 101:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get IPSR Register
 102:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 103:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               IPSR Register value
 104:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 105:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
 106:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 107:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 108:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 109:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 110:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 111:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 112:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 113:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 114:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 115:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get APSR Register
 116:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 117:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               APSR Register value
 118:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 119:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
 120:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 121:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 122:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 123:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 124:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 125:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 126:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 127:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 128:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 129:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get xPSR Register
 130:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 131:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 132:Drivers/CMSIS/Include/cmsis_gcc.h ****     \return               xPSR Register value
 133:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
ARM GAS  /tmp/ccwKCxOP.s 			page 13


 134:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
 135:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 136:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 137:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 138:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 139:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 140:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 141:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 142:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 143:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 144:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 145:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 146:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 147:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 148:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
 149:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 150:Drivers/CMSIS/Include/cmsis_gcc.h ****   register uint32_t result;
 151:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 152:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 153:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 154:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 155:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 156:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 157:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 158:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 159:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 160:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 161:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 162:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
 163:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 164:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 165:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 166:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 167:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 168:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 169:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 170:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 171:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 172:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 173:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
 174:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 175:Drivers/CMSIS/Include/cmsis_gcc.h ****   register uint32_t result;
 176:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 177:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
 178:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 179:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 180:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 181:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 182:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 183:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 184:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 185:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 186:Drivers/CMSIS/Include/cmsis_gcc.h ****     \param [in]    topOfMainStack  Main Stack Pointer value to set
 187:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 188:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
 189:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 190:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
ARM GAS  /tmp/ccwKCxOP.s 			page 14


 191:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 192:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 193:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 194:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 195:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask
 196:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 197:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 198:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 199:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
 200:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 201:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 202:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 203:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) );
 204:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 205:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 206:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 207:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 208:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 209:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask
 210:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 211:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 212:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 213:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
 214:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 215:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 216:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 217:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 218:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 219:Drivers/CMSIS/Include/cmsis_gcc.h **** #if       (__CORTEX_M >= 0x03U)
 220:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 221:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 222:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable FIQ
 223:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
 224:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 225:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 226:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
 227:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 228:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 229:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 230:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 231:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 232:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 233:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable FIQ
 234:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Disables FIQ interrupts by setting the F-bit in the CPSR.
 235:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 236:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 237:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
 238:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 239:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 240:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 241:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 242:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 243:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 244:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority
 245:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Base Priority register.
 246:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 247:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
ARM GAS  /tmp/ccwKCxOP.s 			page 15


 248:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
 249:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 250:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 251:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 252:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 253:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 254:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 255:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 256:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 257:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 258:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority
 259:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register.
 260:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 261:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 262:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
 263:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 264:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 265:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 266:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 267:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 268:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 269:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority with condition
 270:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register only if BASEPRI masking is disable
 271:Drivers/CMSIS/Include/cmsis_gcc.h ****            or the new value increases the BASEPRI priority level.
 272:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 273:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 274:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI_MAX(uint32_t value)
 275:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 276:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (value) : "memory");
 277:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 278:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 279:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 280:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 281:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask
 282:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Fault Mask register.
 283:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 284:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 285:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
 286:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 287:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 288:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 289:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 290:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 291:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 292:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 293:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 294:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 295:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask
 296:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Fault Mask register.
 297:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 298:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 299:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
 300:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 301:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 302:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 303:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 304:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif /* (__CORTEX_M >= 0x03U) */
ARM GAS  /tmp/ccwKCxOP.s 			page 16


 305:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 306:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 307:Drivers/CMSIS/Include/cmsis_gcc.h **** #if       (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U)
 308:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 309:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 310:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get FPSCR
 311:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Floating Point Status/Control register.
 312:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Floating Point Status/Control register value
 313:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 314:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
 315:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 316:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
 317:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 318:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 319:Drivers/CMSIS/Include/cmsis_gcc.h ****   /* Empty asm statement works as a scheduling barrier */
 320:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("");
 321:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 322:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("");
 323:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 324:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 325:Drivers/CMSIS/Include/cmsis_gcc.h ****    return(0);
 326:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 327:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 328:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 329:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 330:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 331:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set FPSCR
 332:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Floating Point Status/Control register.
 333:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    fpscr  Floating Point Status/Control value to set
 334:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 335:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
 336:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 337:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
 338:Drivers/CMSIS/Include/cmsis_gcc.h ****   /* Empty asm statement works as a scheduling barrier */
 339:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("");
 340:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc");
 341:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("");
 342:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 343:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 344:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 345:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif /* (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U) */
 346:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 347:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 348:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 349:Drivers/CMSIS/Include/cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 350:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 351:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 352:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 353:Drivers/CMSIS/Include/cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 354:Drivers/CMSIS/Include/cmsis_gcc.h ****   Access to dedicated instructions
 355:Drivers/CMSIS/Include/cmsis_gcc.h ****   @{
 356:Drivers/CMSIS/Include/cmsis_gcc.h **** */
 357:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 358:Drivers/CMSIS/Include/cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 359:Drivers/CMSIS/Include/cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 360:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 361:Drivers/CMSIS/Include/cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
ARM GAS  /tmp/ccwKCxOP.s 			page 17


 362:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 363:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 364:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 365:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 366:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 367:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 368:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 369:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 370:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   No Operation
 371:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 372:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 373:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
 374:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 375:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("nop");
 376:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 377:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 378:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 379:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 380:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Interrupt
 381:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Interrupt is a hint instruction that suspends execution until one of a number o
 382:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 383:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
 384:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 385:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("wfi");
 347              		.loc 2 385 3
 348              		.syntax unified
 349              	@ 385 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 350 003e 30BF     		wfi
 351              	@ 0 "" 2
 386:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 352              		.loc 2 386 1
 353              		.thumb
 354              		.syntax unified
 355 0040 01E0     		b	.L16
 356              	.L15:
 357              	.LBE9:
 358              	.LBE8:
 359              	.LBB10:
 360              	.LBB11:
 387:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 388:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 389:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 390:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Event
 391:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Event is a hint instruction that permits the processor to enter
 392:Drivers/CMSIS/Include/cmsis_gcc.h ****     a low-power state until one of a number of events occurs.
 393:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 394:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __WFE(void)
 395:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 396:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("wfe");
 361              		.loc 2 396 3
 362              		.syntax unified
 363              	@ 396 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 364 0042 20BF     		wfe
 365              	@ 0 "" 2
 397:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 366              		.loc 2 397 1
 367              		.thumb
ARM GAS  /tmp/ccwKCxOP.s 			page 18


 368              		.syntax unified
 369 0044 00BF     		nop
 370              	.L16:
 371              	.LBE11:
 372              	.LBE10:
 217:Drivers/Src/stm32f10x_pwr.c ****   {   
 218:Drivers/Src/stm32f10x_pwr.c ****     /* Request Wait For Interrupt */
 219:Drivers/Src/stm32f10x_pwr.c ****     __WFI();
 220:Drivers/Src/stm32f10x_pwr.c ****   }
 221:Drivers/Src/stm32f10x_pwr.c ****   else
 222:Drivers/Src/stm32f10x_pwr.c ****   {
 223:Drivers/Src/stm32f10x_pwr.c ****     /* Request Wait For Event */
 224:Drivers/Src/stm32f10x_pwr.c ****     __WFE();
 225:Drivers/Src/stm32f10x_pwr.c ****   }
 226:Drivers/Src/stm32f10x_pwr.c ****   
 227:Drivers/Src/stm32f10x_pwr.c ****   /* Reset SLEEPDEEP bit of Cortex System Control Register */
 228:Drivers/Src/stm32f10x_pwr.c ****   SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP);  
 373              		.loc 1 228 12
 374 0046 064B     		ldr	r3, .L17+4
 375 0048 1B69     		ldr	r3, [r3, #16]
 376 004a 054A     		ldr	r2, .L17+4
 377 004c 23F00403 		bic	r3, r3, #4
 378 0050 1361     		str	r3, [r2, #16]
 229:Drivers/Src/stm32f10x_pwr.c **** }
 379              		.loc 1 229 1
 380 0052 00BF     		nop
 381 0054 1437     		adds	r7, r7, #20
 382              	.LCFI29:
 383              		.cfi_def_cfa_offset 4
 384 0056 BD46     		mov	sp, r7
 385              	.LCFI30:
 386              		.cfi_def_cfa_register 13
 387              		@ sp needed
 388 0058 80BC     		pop	{r7}
 389              	.LCFI31:
 390              		.cfi_restore 7
 391              		.cfi_def_cfa_offset 0
 392 005a 7047     		bx	lr
 393              	.L18:
 394              		.align	2
 395              	.L17:
 396 005c 00700040 		.word	1073770496
 397 0060 00ED00E0 		.word	-536810240
 398              		.cfi_endproc
 399              	.LFE68:
 401              		.section	.text.PWR_EnterSTANDBYMode,"ax",%progbits
 402              		.align	1
 403              		.global	PWR_EnterSTANDBYMode
 404              		.syntax unified
 405              		.thumb
 406              		.thumb_func
 407              		.fpu softvfp
 409              	PWR_EnterSTANDBYMode:
 410              	.LFB69:
 230:Drivers/Src/stm32f10x_pwr.c **** 
 231:Drivers/Src/stm32f10x_pwr.c **** /**
 232:Drivers/Src/stm32f10x_pwr.c ****   * @brief  Enters STANDBY mode.
ARM GAS  /tmp/ccwKCxOP.s 			page 19


 233:Drivers/Src/stm32f10x_pwr.c ****   * @param  None
 234:Drivers/Src/stm32f10x_pwr.c ****   * @retval None
 235:Drivers/Src/stm32f10x_pwr.c ****   */
 236:Drivers/Src/stm32f10x_pwr.c **** void PWR_EnterSTANDBYMode(void)
 237:Drivers/Src/stm32f10x_pwr.c **** {
 411              		.loc 1 237 1
 412              		.cfi_startproc
 413              		@ args = 0, pretend = 0, frame = 0
 414              		@ frame_needed = 1, uses_anonymous_args = 0
 415              		@ link register save eliminated.
 416 0000 80B4     		push	{r7}
 417              	.LCFI32:
 418              		.cfi_def_cfa_offset 4
 419              		.cfi_offset 7, -4
 420 0002 00AF     		add	r7, sp, #0
 421              	.LCFI33:
 422              		.cfi_def_cfa_register 7
 238:Drivers/Src/stm32f10x_pwr.c ****   /* Clear Wake-up flag */
 239:Drivers/Src/stm32f10x_pwr.c ****   PWR->CR |= PWR_CR_CWUF;
 423              		.loc 1 239 11
 424 0004 0B4B     		ldr	r3, .L20
 425 0006 1B68     		ldr	r3, [r3]
 426 0008 0A4A     		ldr	r2, .L20
 427 000a 43F00403 		orr	r3, r3, #4
 428 000e 1360     		str	r3, [r2]
 240:Drivers/Src/stm32f10x_pwr.c ****   /* Select STANDBY mode */
 241:Drivers/Src/stm32f10x_pwr.c ****   PWR->CR |= PWR_CR_PDDS;
 429              		.loc 1 241 11
 430 0010 084B     		ldr	r3, .L20
 431 0012 1B68     		ldr	r3, [r3]
 432 0014 074A     		ldr	r2, .L20
 433 0016 43F00203 		orr	r3, r3, #2
 434 001a 1360     		str	r3, [r2]
 242:Drivers/Src/stm32f10x_pwr.c ****   /* Set SLEEPDEEP bit of Cortex System Control Register */
 243:Drivers/Src/stm32f10x_pwr.c ****   SCB->SCR |= SCB_SCR_SLEEPDEEP;
 435              		.loc 1 243 12
 436 001c 064B     		ldr	r3, .L20+4
 437 001e 1B69     		ldr	r3, [r3, #16]
 438 0020 054A     		ldr	r2, .L20+4
 439 0022 43F00403 		orr	r3, r3, #4
 440 0026 1361     		str	r3, [r2, #16]
 441              	.LBB12:
 442              	.LBB13:
 385:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 443              		.loc 2 385 3
 444              		.syntax unified
 445              	@ 385 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 446 0028 30BF     		wfi
 447              	@ 0 "" 2
 386:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 448              		.loc 2 386 1
 449              		.thumb
 450              		.syntax unified
 451 002a 00BF     		nop
 452              	.LBE13:
 453              	.LBE12:
 244:Drivers/Src/stm32f10x_pwr.c **** /* This option is used to ensure that store operations are completed */
ARM GAS  /tmp/ccwKCxOP.s 			page 20


 245:Drivers/Src/stm32f10x_pwr.c **** #if defined ( __CC_ARM   )
 246:Drivers/Src/stm32f10x_pwr.c ****   __force_stores();
 247:Drivers/Src/stm32f10x_pwr.c **** #endif
 248:Drivers/Src/stm32f10x_pwr.c ****   /* Request Wait For Interrupt */
 249:Drivers/Src/stm32f10x_pwr.c ****   __WFI();
 250:Drivers/Src/stm32f10x_pwr.c **** }
 454              		.loc 1 250 1
 455 002c 00BF     		nop
 456 002e BD46     		mov	sp, r7
 457              	.LCFI34:
 458              		.cfi_def_cfa_register 13
 459              		@ sp needed
 460 0030 80BC     		pop	{r7}
 461              	.LCFI35:
 462              		.cfi_restore 7
 463              		.cfi_def_cfa_offset 0
 464 0032 7047     		bx	lr
 465              	.L21:
 466              		.align	2
 467              	.L20:
 468 0034 00700040 		.word	1073770496
 469 0038 00ED00E0 		.word	-536810240
 470              		.cfi_endproc
 471              	.LFE69:
 473              		.section	.text.PWR_GetFlagStatus,"ax",%progbits
 474              		.align	1
 475              		.global	PWR_GetFlagStatus
 476              		.syntax unified
 477              		.thumb
 478              		.thumb_func
 479              		.fpu softvfp
 481              	PWR_GetFlagStatus:
 482              	.LFB70:
 251:Drivers/Src/stm32f10x_pwr.c **** 
 252:Drivers/Src/stm32f10x_pwr.c **** /**
 253:Drivers/Src/stm32f10x_pwr.c ****   * @brief  Checks whether the specified PWR flag is set or not.
 254:Drivers/Src/stm32f10x_pwr.c ****   * @param  PWR_FLAG: specifies the flag to check.
 255:Drivers/Src/stm32f10x_pwr.c ****   *   This parameter can be one of the following values:
 256:Drivers/Src/stm32f10x_pwr.c ****   *     @arg PWR_FLAG_WU: Wake Up flag
 257:Drivers/Src/stm32f10x_pwr.c ****   *     @arg PWR_FLAG_SB: StandBy flag
 258:Drivers/Src/stm32f10x_pwr.c ****   *     @arg PWR_FLAG_PVDO: PVD Output
 259:Drivers/Src/stm32f10x_pwr.c ****   * @retval The new state of PWR_FLAG (SET or RESET).
 260:Drivers/Src/stm32f10x_pwr.c ****   */
 261:Drivers/Src/stm32f10x_pwr.c **** FlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG)
 262:Drivers/Src/stm32f10x_pwr.c **** {
 483              		.loc 1 262 1
 484              		.cfi_startproc
 485              		@ args = 0, pretend = 0, frame = 16
 486              		@ frame_needed = 1, uses_anonymous_args = 0
 487              		@ link register save eliminated.
 488 0000 80B4     		push	{r7}
 489              	.LCFI36:
 490              		.cfi_def_cfa_offset 4
 491              		.cfi_offset 7, -4
 492 0002 85B0     		sub	sp, sp, #20
 493              	.LCFI37:
 494              		.cfi_def_cfa_offset 24
ARM GAS  /tmp/ccwKCxOP.s 			page 21


 495 0004 00AF     		add	r7, sp, #0
 496              	.LCFI38:
 497              		.cfi_def_cfa_register 7
 498 0006 7860     		str	r0, [r7, #4]
 263:Drivers/Src/stm32f10x_pwr.c ****   FlagStatus bitstatus = RESET;
 499              		.loc 1 263 14
 500 0008 0023     		movs	r3, #0
 501 000a FB73     		strb	r3, [r7, #15]
 264:Drivers/Src/stm32f10x_pwr.c ****   /* Check the parameters */
 265:Drivers/Src/stm32f10x_pwr.c ****   assert_param(IS_PWR_GET_FLAG(PWR_FLAG));
 266:Drivers/Src/stm32f10x_pwr.c ****   
 267:Drivers/Src/stm32f10x_pwr.c ****   if ((PWR->CSR & PWR_FLAG) != (uint32_t)RESET)
 502              		.loc 1 267 11
 503 000c 084B     		ldr	r3, .L26
 504 000e 5A68     		ldr	r2, [r3, #4]
 505              		.loc 1 267 17
 506 0010 7B68     		ldr	r3, [r7, #4]
 507 0012 1340     		ands	r3, r3, r2
 508              		.loc 1 267 6
 509 0014 002B     		cmp	r3, #0
 510 0016 02D0     		beq	.L23
 268:Drivers/Src/stm32f10x_pwr.c ****   {
 269:Drivers/Src/stm32f10x_pwr.c ****     bitstatus = SET;
 511              		.loc 1 269 15
 512 0018 0123     		movs	r3, #1
 513 001a FB73     		strb	r3, [r7, #15]
 514 001c 01E0     		b	.L24
 515              	.L23:
 270:Drivers/Src/stm32f10x_pwr.c ****   }
 271:Drivers/Src/stm32f10x_pwr.c ****   else
 272:Drivers/Src/stm32f10x_pwr.c ****   {
 273:Drivers/Src/stm32f10x_pwr.c ****     bitstatus = RESET;
 516              		.loc 1 273 15
 517 001e 0023     		movs	r3, #0
 518 0020 FB73     		strb	r3, [r7, #15]
 519              	.L24:
 274:Drivers/Src/stm32f10x_pwr.c ****   }
 275:Drivers/Src/stm32f10x_pwr.c ****   /* Return the flag status */
 276:Drivers/Src/stm32f10x_pwr.c ****   return bitstatus;
 520              		.loc 1 276 10
 521 0022 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 277:Drivers/Src/stm32f10x_pwr.c **** }
 522              		.loc 1 277 1
 523 0024 1846     		mov	r0, r3
 524 0026 1437     		adds	r7, r7, #20
 525              	.LCFI39:
 526              		.cfi_def_cfa_offset 4
 527 0028 BD46     		mov	sp, r7
 528              	.LCFI40:
 529              		.cfi_def_cfa_register 13
 530              		@ sp needed
 531 002a 80BC     		pop	{r7}
 532              	.LCFI41:
 533              		.cfi_restore 7
 534              		.cfi_def_cfa_offset 0
 535 002c 7047     		bx	lr
 536              	.L27:
ARM GAS  /tmp/ccwKCxOP.s 			page 22


 537 002e 00BF     		.align	2
 538              	.L26:
 539 0030 00700040 		.word	1073770496
 540              		.cfi_endproc
 541              	.LFE70:
 543              		.section	.text.PWR_ClearFlag,"ax",%progbits
 544              		.align	1
 545              		.global	PWR_ClearFlag
 546              		.syntax unified
 547              		.thumb
 548              		.thumb_func
 549              		.fpu softvfp
 551              	PWR_ClearFlag:
 552              	.LFB71:
 278:Drivers/Src/stm32f10x_pwr.c **** 
 279:Drivers/Src/stm32f10x_pwr.c **** /**
 280:Drivers/Src/stm32f10x_pwr.c ****   * @brief  Clears the PWR's pending flags.
 281:Drivers/Src/stm32f10x_pwr.c ****   * @param  PWR_FLAG: specifies the flag to clear.
 282:Drivers/Src/stm32f10x_pwr.c ****   *   This parameter can be one of the following values:
 283:Drivers/Src/stm32f10x_pwr.c ****   *     @arg PWR_FLAG_WU: Wake Up flag
 284:Drivers/Src/stm32f10x_pwr.c ****   *     @arg PWR_FLAG_SB: StandBy flag
 285:Drivers/Src/stm32f10x_pwr.c ****   * @retval None
 286:Drivers/Src/stm32f10x_pwr.c ****   */
 287:Drivers/Src/stm32f10x_pwr.c **** void PWR_ClearFlag(uint32_t PWR_FLAG)
 288:Drivers/Src/stm32f10x_pwr.c **** {
 553              		.loc 1 288 1
 554              		.cfi_startproc
 555              		@ args = 0, pretend = 0, frame = 8
 556              		@ frame_needed = 1, uses_anonymous_args = 0
 557              		@ link register save eliminated.
 558 0000 80B4     		push	{r7}
 559              	.LCFI42:
 560              		.cfi_def_cfa_offset 4
 561              		.cfi_offset 7, -4
 562 0002 83B0     		sub	sp, sp, #12
 563              	.LCFI43:
 564              		.cfi_def_cfa_offset 16
 565 0004 00AF     		add	r7, sp, #0
 566              	.LCFI44:
 567              		.cfi_def_cfa_register 7
 568 0006 7860     		str	r0, [r7, #4]
 289:Drivers/Src/stm32f10x_pwr.c ****   /* Check the parameters */
 290:Drivers/Src/stm32f10x_pwr.c ****   assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
 291:Drivers/Src/stm32f10x_pwr.c ****          
 292:Drivers/Src/stm32f10x_pwr.c ****   PWR->CR |=  PWR_FLAG << 2;
 569              		.loc 1 292 11
 570 0008 054B     		ldr	r3, .L29
 571 000a 1A68     		ldr	r2, [r3]
 572              		.loc 1 292 24
 573 000c 7B68     		ldr	r3, [r7, #4]
 574 000e 9B00     		lsls	r3, r3, #2
 575              		.loc 1 292 11
 576 0010 0349     		ldr	r1, .L29
 577 0012 1343     		orrs	r3, r3, r2
 578 0014 0B60     		str	r3, [r1]
 293:Drivers/Src/stm32f10x_pwr.c **** }
 579              		.loc 1 293 1
ARM GAS  /tmp/ccwKCxOP.s 			page 23


 580 0016 00BF     		nop
 581 0018 0C37     		adds	r7, r7, #12
 582              	.LCFI45:
 583              		.cfi_def_cfa_offset 4
 584 001a BD46     		mov	sp, r7
 585              	.LCFI46:
 586              		.cfi_def_cfa_register 13
 587              		@ sp needed
 588 001c 80BC     		pop	{r7}
 589              	.LCFI47:
 590              		.cfi_restore 7
 591              		.cfi_def_cfa_offset 0
 592 001e 7047     		bx	lr
 593              	.L30:
 594              		.align	2
 595              	.L29:
 596 0020 00700040 		.word	1073770496
 597              		.cfi_endproc
 598              	.LFE71:
 600              		.text
 601              	.Letext0:
 602              		.file 3 "/home/pico/tools/gcc-arm-none-eabi-10-2020-q4-major/arm-none-eabi/include/machine/_defaul
 603              		.file 4 "/home/pico/tools/gcc-arm-none-eabi-10-2020-q4-major/arm-none-eabi/include/sys/_stdint.h"
 604              		.file 5 "Drivers/CMSIS/Include/core_cm3.h"
 605              		.file 6 "Inc/stm32f10x.h"
ARM GAS  /tmp/ccwKCxOP.s 			page 24


DEFINED SYMBOLS
                            *ABS*:0000000000000000 stm32f10x_pwr.c
     /tmp/ccwKCxOP.s:16     .text.PWR_DeInit:0000000000000000 $t
     /tmp/ccwKCxOP.s:24     .text.PWR_DeInit:0000000000000000 PWR_DeInit
     /tmp/ccwKCxOP.s:54     .text.PWR_BackupAccessCmd:0000000000000000 $t
     /tmp/ccwKCxOP.s:61     .text.PWR_BackupAccessCmd:0000000000000000 PWR_BackupAccessCmd
     /tmp/ccwKCxOP.s:103    .text.PWR_BackupAccessCmd:000000000000001c $d
     /tmp/ccwKCxOP.s:108    .text.PWR_PVDCmd:0000000000000000 $t
     /tmp/ccwKCxOP.s:115    .text.PWR_PVDCmd:0000000000000000 PWR_PVDCmd
     /tmp/ccwKCxOP.s:157    .text.PWR_PVDCmd:000000000000001c $d
     /tmp/ccwKCxOP.s:162    .text.PWR_PVDLevelConfig:0000000000000000 $t
     /tmp/ccwKCxOP.s:169    .text.PWR_PVDLevelConfig:0000000000000000 PWR_PVDLevelConfig
     /tmp/ccwKCxOP.s:226    .text.PWR_PVDLevelConfig:0000000000000034 $d
     /tmp/ccwKCxOP.s:231    .text.PWR_WakeUpPinCmd:0000000000000000 $t
     /tmp/ccwKCxOP.s:238    .text.PWR_WakeUpPinCmd:0000000000000000 PWR_WakeUpPinCmd
     /tmp/ccwKCxOP.s:280    .text.PWR_WakeUpPinCmd:000000000000001c $d
     /tmp/ccwKCxOP.s:285    .text.PWR_EnterSTOPMode:0000000000000000 $t
     /tmp/ccwKCxOP.s:292    .text.PWR_EnterSTOPMode:0000000000000000 PWR_EnterSTOPMode
     /tmp/ccwKCxOP.s:396    .text.PWR_EnterSTOPMode:000000000000005c $d
     /tmp/ccwKCxOP.s:402    .text.PWR_EnterSTANDBYMode:0000000000000000 $t
     /tmp/ccwKCxOP.s:409    .text.PWR_EnterSTANDBYMode:0000000000000000 PWR_EnterSTANDBYMode
     /tmp/ccwKCxOP.s:468    .text.PWR_EnterSTANDBYMode:0000000000000034 $d
     /tmp/ccwKCxOP.s:474    .text.PWR_GetFlagStatus:0000000000000000 $t
     /tmp/ccwKCxOP.s:481    .text.PWR_GetFlagStatus:0000000000000000 PWR_GetFlagStatus
     /tmp/ccwKCxOP.s:539    .text.PWR_GetFlagStatus:0000000000000030 $d
     /tmp/ccwKCxOP.s:544    .text.PWR_ClearFlag:0000000000000000 $t
     /tmp/ccwKCxOP.s:551    .text.PWR_ClearFlag:0000000000000000 PWR_ClearFlag
     /tmp/ccwKCxOP.s:596    .text.PWR_ClearFlag:0000000000000020 $d

UNDEFINED SYMBOLS
RCC_APB1PeriphResetCmd
